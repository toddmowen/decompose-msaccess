'
' Usage: decompose-msaccess.vbs DATABASE [OUTPUT FOLDER]
'
' Generates a set of source files and a build script compose-DATABASE.vbs
' which can be used to rebuild the specified database.
'
' To download the latest release or contribute to this project, visit:
' http://github.com/toddmowen/decompose-msaccess
'
' Inspiration for this project came from Oliver:
' http://stackoverflow.com/questions/187506/how-do-you-use-version-control-with-access-development
'
'
'
' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <http://www.gnu.org/licenses/>.
'


Option Explicit

' Possible values for EXPORT_DATA are:
' "none"      - Decompose table schema only, not data.
' "xml-embed" - Use the ExportXML/ImportXML methods; any OLE Objects (or BLOBs)
'               will be embedded in the XML file. This is not recommended if the
'               database contains a lot of binary data (anything more than a
'               hundred kilobytes IN TOTAL!) as ImportXML has performance issues
'               importing such data (observed in Access 2003).
' "xml-md5"   - (Default) Export XML, but strip OLE Objects/BLOBs from the file.
'               Instead, each BLOB will be written as a separate file, named
'               according to the MD5 hash of its contents.
' "csv-md5"   - (NOT RECOMMENDED) Use the TransferText method to read and write
'               data. Numeric data will be truncated to 2 decimal places (to
'               avoid this, a schema.ini file would need to be supplied).
Const EXPORT_DATA = "xml-md5"

Dim IGNORED_FIELD_PROPERTIES
IGNORED_FIELD_PROPERTIES = Array("Value", "ValidateOnSet", "ForeignName", _
	"FieldSize", "OriginalValue", "VisibleValue", "GUID")

Const acCmdAppMaximize = 10
Const acAppendData = 2
Const acExportDelim = 2
Const acImportDelim = 0

Const acTable = 0
Const acQuery = 1 
Const acForm = 2 
Const acReport = 3
Const acMacro = 4 
Const acModule = 5 
Const acDataAccessPage = 6

Const acSysCmdInitMeter = 1
Const acSysCmdUpdateMeter = 2
Const acSysCmdRemoveMeter = 3
Const acSysCmdSetStatus = 4

Const dbDescending = 1

Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2

Const dbRelationUnique = 1
Const dbRelationDontEnforce = 2
Const dbRelationInherited = 4
Const dbRelationUpdateCascade = 256
Const dbRelationDeleteCascade = 4096
Const dbRelationLeft = 16777216
Const dbRelationRight = 33554432

Const dbBoolean = 1
Const dbByte = 2
Const dbInteger = 3
Const dbLong = 4
Const dbCurrency = 5
Const dbSingle = 6
Const dbDouble = 7
Const dbDate = 8
Const dbBinary = 9
Const dbText = 10
Const dbLongBinary = 11
Const dbMemo = 12
Const dbGUID = 15
Const dbDecimal = 20


Function Usage()
	MsgBox "Usage: decompose-msaccess.vbs DATABASE [OUTPUT FOLDER]", vbInformation, "Decompose MS-Access"
End Function


Function DecomposeDatabase(oAccess, sOutputFolder)
	Dim sScriptFile, oScriptStream

	sScriptFile = fso.BuildPath(sOutputFolder, "compose-" & fso.GetBaseName(oAccess.CurrentProject.Name) & ".VBS")
	Set oScriptStream = fso.CreateTextFile(sScriptFile, True)
        WriteScriptHeader oScriptStream
        WriteScriptFunctions oScriptStream

	ScriptCreate oAccess, oScriptStream
	ScriptProperties oAccess, oScriptStream
	ScriptReferences oAccess, oScriptStream
	ScriptTables oAccess, oScriptStream, sOutputFolder
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentData.AllQueries, acQuery, "queries", "ADQ"
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentProject.AllForms, acForm, "forms", "ADF"
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentProject.AllReports, acReport, "reports", "ADR"
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentProject.AllMacros, acMacro, "macros", "ADM"
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentProject.AllModules, acModule, "modules", "BAS"
	ScriptObjects oAccess, oScriptStream, sOutputFolder, oAccess.CurrentProject.AllDataAccessPages, acDataAccessPage, "pages", "ADP"
	ScriptClose oAccess, oScriptStream

	oScriptStream.Close
End Function


Function writeScriptHeader(oScriptStream)
	oScriptStream.WriteLine "'"
	oScriptStream.WriteLine "' Automatically generated by decompose-msaccess.vbs"
	oScriptStream.WriteLine "'"
	oScriptStream.WriteLine
End Function


Function writeSQLHeader(oScriptStream)
	oScriptStream.WriteLine "--"
	oScriptStream.WriteLine "-- Automatically generated by decompose-msaccess.vbs"
	oScriptStream.WriteLine "--"
	oScriptStream.WriteLine
End Function


Function writeScriptFunctions(oScriptStream)
	oScriptStream.WriteLine "Function SetProperty(oAccess, sPropName, propType, propValue)"
	oScriptStream.WriteLine "	On Error Resume Next"
	oScriptStream.WriteLine "	oAccess.CurrentDb.Properties(sPropName) = propValue"
	oScriptStream.WriteLine "	If Err.Number = 3270 Then"
	oScriptStream.WriteLine "		Err.Clear"
	oScriptStream.WriteLine "		oAccess.CurrentDb.Properties.Append oAccess.CurrentDb.CreateProperty(sPropName, propType, propValue)"
	oScriptStream.WriteLine "	End If"
	oScriptStream.WriteLine "End Function"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "Function SetProperty2(oTarget, sPropName, propType, propValue)"
	oScriptStream.WriteLine "	On Error Resume Next"
	oScriptStream.WriteLine "	oTarget.Properties(sPropName) = propValue"
	oScriptStream.WriteLine "	If Err.Number = 3270 Then"
	oScriptStream.WriteLine "		Err.Clear"
	oScriptStream.WriteLine "		oTarget.Properties.Append oTarget.CreateProperty(sPropName, propType, propValue)"
	oScriptStream.WriteLine "	End If"
	oScriptStream.WriteLine "End Function"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "Function ExecuteFile(sPath)"
	oScriptStream.WriteLine "	Set oFile = fso.OpenTextFile(sPath, 1)"
	oScriptStream.WriteLine "	Execute oFile.ReadAll"
	oScriptStream.WriteLine "	oFile.Close"
	oScriptStream.WriteLine "End Function"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "Function ExecuteSQL(sPath)"
	oScriptStream.WriteLine "	sSQL = """""
	oScriptStream.WriteLine "	sVB = """""
	oScriptStream.WriteLine
	oScriptStream.WriteLine "	Set oFile = fso.OpenTextFile(sPath, 1)"
	oScriptStream.WriteLine "	While Not oFile.AtEndOfStream"
	oScriptStream.WriteLine "		sLine = Trim(oFile.ReadLine)"
	oScriptStream.WriteLine "		If Left(sLine, 3) = ""--!"" Then"
	oScriptStream.WriteLine "			sVB = sVB & Mid(sLine, 4) & vbCrLf"
	oScriptStream.WriteLine "		ElseIf sLine <> """" And Left(sLine, 2) <> ""--"" Then"
	oScriptStream.WriteLine "			If Left(sLine, 6) = ""CREATE"" And sSQL <> """" Then"
	oScriptStream.WriteLine "				oAccess.CurrentProject.Connection.Execute sSQL"
	oScriptStream.WriteLine "				sSql = """""
	oScriptStream.WriteLine "			End If"
	oScriptStream.WriteLine "			sSQL = sSQL & sLine & "" """
	oScriptStream.WriteLine "		End If"
	oScriptStream.WriteLine "	Wend"
	oScriptStream.WriteLine "	oFile.Close"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "	' Use ADO to execute (DAO doesn't support some DDL syntax, e.g. DECIMAL)"
	oScriptStream.WriteLine "	oAccess.CurrentProject.Connection.Execute sSQL"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "	If sVB <> """" Then"
	oScriptStream.WriteLine "		With oAccess"
	oScriptStream.WriteLine "			Execute sVB"
	oScriptStream.WriteLine "		End With"
	oScriptStream.WriteLine "	End If"
	oScriptStream.WriteLine "End Function"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "Dim oStream : Set oStream = Nothing"
	oScriptStream.WriteLine "Function LoadBlob(oRecordset, sColumnName, sPath)"
	oScriptStream.WriteLine "	If oStream Is Nothing Then"
	oScriptStream.WriteLine "		Set oStream = CreateObject(""ADODB.Stream"")"
	oScriptStream.WriteLine "		oStream.Type = " & adTypeBinary
	oScriptStream.WriteLine "		oStream.Open"
	oScriptStream.WriteLine "	End If"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "	oStream.LoadFromFile sPath"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "	oRecordset.Edit"
	oScriptStream.WriteLine "	oRecordset(sColumnName).Value = oStream.Read"
	oScriptStream.WriteLine "	oRecordset.Update"
	oScriptStream.WriteLine "End Function"
	oScriptStream.WriteLine
End Function


Function ScriptTables(oAccess, oScriptStream, sOutputFolder)
	Dim arrTables, sSubFolder, sBlobSubFolder, sTableName, i

	arrTables = OrderTables(oAccess.CurrentDb)

	oAccess.SysCmd acSysCmdInitMeter, "Decomposing table schema", UBound(arrTables)
	sSubFolder = fso.GetBaseName(oAccess.CurrentProject.Name) & "-schema"
	For i = 0 To UBound(arrTables)
		sTableName = arrTables(i)
		oAccess.SysCmd acSysCmdUpdateMeter, i
		ScriptTableSchema oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName
	Next
	oScriptStream.WriteLine

	If EXPORT_DATA <> "none" Then
		oAccess.SysCmd acSysCmdInitMeter, "Exporting table data", UBound(arrTables)
		sSubFolder = fso.GetBaseName(oAccess.CurrentProject.Name) & "-data"
		sBlobSubFolder = fso.GetBaseName(oAccess.CurrentProject.Name) & "-blobs"
		For i = 0 To UBound(arrTables)
			sTableName = arrTables(i)
			oAccess.SysCmd acSysCmdUpdateMeter, i
			If oAccess.CurrentDb.TableDefs(sTableName).RecordCount > 0 Then
				ScriptTableData oAccess, oScriptStream, sOutputFolder, sSubFolder, sBlobSubFolder, sTableName
			End If
		Next
		oScriptStream.WriteLine
	End If

	oAccess.SysCmd acSysCmdRemoveMeter
	oAccess.SysCmd acSysCmdSetStatus, " "
End Function


Function ScriptTableSchema(oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName)
	Dim oDatabase, oSQLStream, oTableDef

	Set oDatabase = oAccess.CurrentDb
	Set oTableDef = oDatabase.TableDefs(sTableName)

	Set oSQLStream = fso.CreateTextFile(ExportPath(sOutputFolder, sSubFolder, sTableName & ".SQL"), True)
	writeSQLHeader oSQLStream
	oSQLStream.WriteLine "CREATE TABLE " & sTableName & " ("
	ScriptTableFields oTableDef, oSQLStream
	ScriptTableRelations oAccess.CurrentDb, oTableDef, oSQLStream
	oSQLStream.WriteLine ")"
	oSQLStream.WriteLine

	ScriptTableIndexes oTableDef, oSQLStream

	oSQLStream.Close
	
	oScriptStream.WriteLine "ExecuteSQL " & ImportPath(sSubFolder, sTableName & ".SQL")
End Function


Function ScriptTableFields(oTableDef, oSQLStream)
	Dim oField, sLinePrefix

	sLinePrefix = "        "
	For Each oField In oTableDef.Fields
		oSQLStream.Write sLinePrefix
		ScriptField oField, oSQLStream
		sLinePrefix = "       ,"
	Next
End Function


Function ScriptTableIndexes(oTableDef, oSQLStream)
	Dim oIndex, oField, sLinePrefix

	For Each oIndex In oTableDef.Indexes
		If Not oIndex.Foreign Then  ' foreign key constraints have already been scripted
			If oIndex.Unique Then
				oSQLStream.Write "CREATE UNIQUE INDEX"
			Else
				oSQLStream.Write "CREATE INDEX"
			End If
			oSQLStream.WriteLine " [" & oIndex.Name & "] ON [" & oTableDef.Name & "] ("

			sLinePrefix = "        "
			For Each oField In oIndex.Fields
				oSQLStream.Write sLinePrefix & "[" & oField.Name & "]"
				If oField.Attributes And dbDescending > 0 Then
					oSQLStream.WriteLine " DESC"
				Else
					oSQLStream.WriteLine " ASC"
				End If
				sLinePrefix = "       ,"
			Next

			oSQLStream.WriteLine ")"
			If oIndex.Primary Then
				oSQLStream.WriteLine "WITH PRIMARY"
			ElseIf oIndex.Required Then
				oSQLStream.WriteLine "WITH DISALLOW NULL"
			ElseIf oIndex.IgnoreNulls Then
				oSQLStream.WriteLine "WITH IGNORE NULL"
			End If
			oSQLStream.WriteLine
		End If
	Next
End Function


Function ScriptTableRelations(oDatabase, oTableDef, oSQLStream)
	Dim oRelation

	For Each oRelation In oDatabase.Relations
		If oRelation.ForeignTable = oTableDef.Name Then
			oSQLStream.WriteLine
			If oRelation.Attributes And dbRelationDontEnforce Then
				oSQLStream.WriteLine "-- Unenforced relation:"
				oSQLStream.WriteLine "--"
				ScriptRelationVBS oRelation, oSQLStream
			Else
				ScriptRelationSQL oTableDef, oRelation, oSQLStream
			End If
		End If
	Next
End Function


Function ScriptRelationVBS(oRelation, oSQLStream)
	Dim oField

	oSQLStream.WriteLine "--! Set oDatabase = .CurrentDb"
	oSQLStream.WriteLine "--! Set oRelation = oDatabase.CreateRelation(""" & oRelation.Name & """" _
		& ", """ & oRelation.Table & """, """ & oRelation.ForeignTable & """, " & oRelation.Attributes & ")"
	For Each oField In oRelation.Fields
		oSQLStream.Write "--! Set oField = oRelation.CreateField(""" & oField.Name & """)"
		oSQLStream.Write " : oField.ForeignName = """ & oField.ForeignName & """"
		oSQLStream.WriteLine " : oRelation.Fields.Append oField"
	Next
	oSQLStream.WriteLine "--! oDatabase.Relations.Append oRelation"
End Function


Function ScriptRelationSQL(oTableDef, oRelation, oSQLStream)
	Dim oField, sItemPrefix

	oSQLStream.WriteLine "       ,CONSTRAINT [" & oRelation.Name & "]"

	oSQLStream.Write "                FOREIGN KEY"
	If Not CollectionContains(oTableDef.Indexes, oRelation.Name) Then oSQLStream.Write " NO INDEX"
	oSQLStream.Write " ("
	sItemPrefix = ""
	For Each oField In oRelation.Fields
		oSQLStream.Write sItemPrefix & "[" & oField.ForeignName & "]"
		sItemPrefix = ", "
	Next
	oSQLStream.WriteLine ")"

	oSQLStream.Write "                REFERENCES [" & oRelation.Table & "] ("
	sItemPrefix = ""
	For Each oField In oRelation.Fields
		oSQLStream.Write sItemPrefix & "[" & oField.Name & "]"
		sItemPrefix = ", "
	Next
	oSQLStream.WriteLine ")"

	If oRelation.Attributes And dbRelationUpdateCascade Then
		oSQLStream.WriteLine "                ON UPDATE CASCADE"
	End If

	If oRelation.Attributes And dbRelationDeleteCascade Then
		oSQLStream.WriteLine "                ON DELETE CASCADE"
	End If
End Function


Function CollectionContains(oCollection, key)
	On Error Resume Next
	oCollection key  ' attempt lookup
	CollectionContains = (Err.Number = 0)
End Function


Function ScriptField(oField, oSQLStream)
	Dim oCat, oCol, oProp

	oSQLStream.Write "[" & oField.Name & "] "

	Select Case oField.Type
	Case dbBoolean
		oSQLStream.Write "YESNO"
	Case dbByte
		oSQLStream.Write "BYTE"
	Case dbInteger
		oSQLStream.Write "INTEGER"
	Case dbLong
		oSQLStream.Write "LONG"
	Case dbCurrency
		oSQLStream.Write "CURRENCY"
	Case dbSingle
		oSQLStream.Write "SINGLE"
	Case dbDouble
		oSQLStream.Write "DOUBLE"
	Case dbDate
		oSQLStream.Write "DATETIME"
	Case dbBinary
		oSQLStream.Write "BINARY"
	Case dbText
		oSQLStream.Write "TEXT(" & oField.Size & ")"
	Case dbLongBinary
		oSQLStream.Write "LONGBINARY"
	Case dbMemo
		oSQLStream.Write "MEMO"
	Case dbGUID
		oSQLStream.Write "GUID"
	Case dbDecimal
		' Use ADOX to access precision and scale (not available via DAO)
		Set oCat = CreateObject("ADOX.Catalog")
		oCat.ActiveConnection = oAccess.CurrentProject.BaseConnectionString
		Set oCol = oCat.Tables(oField.SourceTable).Columns(oField.Name)
		oSQLStream.Write "DECIMAL(" & oCol.Precision & ", " & oCol.NumericScale & ")"
	Case Else
		Err.Raise 513, , "ScriptField: unknown type " & oField.Type
	End Select

	Set oProp = GetProperty(oField, "UnicodeCompression")
	If Not oProp Is Nothing Then
		If oProp.Value Then oSQLStream.Write " WITH COMP"
	End If

	If oField.Required Then oSQLStream.Write " NOT NULL"

	oSQLStream.WriteLine

	If oField.Type = 10 or oField.Type = 12 Then  ' dbText or dbMemo
		' Always explicitly set true or false for AllowZeroLength
		' (see http://support.microsoft.com/kb/217156)
		Dim sValue
		Set oProp = GetProperty(oField, "AllowZeroLength")
		If oProp Is Nothing Then
			sValue = "False"
		Else
			sValue = oProp.Value
		End If

		oSQLStream.WriteLine "--! .CurrentDb.TableDefs(""" & oField.SourceTable & """)" _
		 & ".Fields(""" & oField.Name & """).AllowZeroLength = " & sValue
	End If
End Function


Function ValueSQL(val)
	Select Case VarType(val)
	Case vbInteger, vbLong, vbSingle, vbDouble:
		ValueSQL = Str(val)
	Case vbString:
		ValueSQL = """" & Replace(val, """", """""") & """"
	Case Else
		Err.Raise 513, , "Please update ValueSQL function to handle VarType " & VarType(val)
	End Select
End Function


Function GetProperty(oSource, sPropName)
	Set GetProperty = Nothing
	On Error Resume Next  ' Ignore property not found error
	Set GetProperty = oSource.Properties(sPropName)
End Function


Function ScriptProperties2(oSource, oScriptStream, sTarget, arrIgnored)
	Dim oProp

	For Each oProp In oSource.Properties
		If Not InArray(arrIgnored, oProp.Name) Then
			oScriptStream.WriteLine "SetProperty2 " & sTarget & ", """ & oProp.Name & """, " & CStr(oProp.Type) & ", """ & Replace(oProp.Value, """", """""") & """"
		End If
	Next
	oScriptStream.WriteLine
End Function


Function InArray(arr, target)
	Dim value

	For Each value In arr
		If target = value Then
			InArray = True
			Exit Function
		End If
	Next

	InArray = False
End Function


Function ScriptTableData(oAccess, oScriptStream, sOutputFolder, sSubFolder, sBlobSubFolder, sTableName)
	Select Case EXPORT_DATA
	Case "xml-embed"
		ScriptDataXML oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName
	Case "xml-md5"
		ScriptDataXML oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName
		RemoveBlobsFromXML oAccess, sTableName, ExportPath(sOutputFolder, sSubFolder, sTableName & ".XML")
		ScriptBlobsMD5 oAccess, oScriptStream, sOutputFolder, sBlobSubFolder, sTableName
	Case "csv-md5"
		ScriptDataCSV oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName
		ScriptBlobsMD5 oAccess, oScriptStream, sOutputFolder, sBlobSubFolder, sTableName
	Case Else
		Err.Raise 513, , "Unknown value for EXPORT_DATA: " & EXPORT_DATA
	End Select
End Function


Function ScriptDataXML(oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName)
	oAccess.ExportXML acTable, sTableName, ExportPath(sOutputFolder, sSubFolder, sTableName & ".XML")
	oScriptStream.WriteLine "oAccess.ImportXML " & ImportPath(sSubFolder, sTableName & ".XML") & ", " & CStr(acAppendData)
End Function


Function RemoveBlobsFromXml(oAccess, sTableName, sPath)
	Dim arrFieldNames, regexStartTag, regexEndTag
	Dim oIn, oOut, sLine

	arrFieldNames = GetFieldNamesByType(oAccess, sTableName, dbLongBinary)
	If UBound(arrFieldNames) = -1 Then Exit Function

	' FIXME: should escape field names for use in regular expression
	Set regexStartTag = New RegExp
	regexStartTag.Pattern = "^<(" & Join(arrFieldNames, "|") & ")>"
	Set regexEndTag = New RegExp
	regexEndTag.Pattern = "</(" & Join(arrFieldNames, "|") & ")>$"

	Set oIn = fso.OpenTextFile(sPath, 1)
	Set oOut = fso.OpenTextFile(spath & ".TMP", 2, True)

	While Not oIn.AtEndOfStream
		sLine = oIn.ReadLine

		If regexStartTag.Test(sLine) Then
			While Not regexEndTag.Test(sLine)
				sLine = oIn.ReadLine
			Wend
		Else
			oOut.WriteLine sLine
		End If
	Wend

	oIn.Close
	oOut.Close

	fso.DeleteFile sPath
	fso.MoveFile sPath & ".TMP", sPath
End Function


Function GetFieldNamesByType(oAccess, sTableName, iType)
	Dim oDatabase, oTableDef, oField
	Dim arrFieldNames : arrFieldNames = Array()
	
	Set oDatabase = oAccess.CurrentDb
	Set oTableDef = oDatabase.TableDefs(sTableName)

	For Each oField In oTableDef.Fields
		If oField.Type = iType Then
			ReDim Preserve arrFieldNames(UBound(arrFieldNames) + 1)
			arrFieldNames(UBound(arrFieldNames)) = oField.Name
		End If
	Next

	GetFieldNamesByType = arrFieldNames
End Function


Function ScriptDataCSV(oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName)
	oAccess.DoCmd.TransferText acExportDelim, , sTableName, ExportPath(sOutputFolder, sSubFolder, sTableName & ".CSV"), True, , 65001  ' UTF8
	oScriptStream.WriteLine "oAccess.DoCmd.TransferText " & acImportDelim & ", , """ & sTableName & """, " & ImportPath(sSubFolder, sTableName & ".CSV") & ", True, , 65001"
End Function


Function ScriptBlobsMD5(oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName)
	Dim arrFieldNames, sFieldName, oBlobScriptStream

	arrFieldNames = GetFieldNamesByType(oAccess, sTableName, dbLongBinary)
	If UBound(arrFieldNames) = -1 Then Exit Function

	Set oBlobScriptStream = fso.CreateTextFile(ExportPath(sOutputFolder, sSubFolder, sTableName & ".VBS"), True)
        writeScriptHeader oBlobScriptStream

	For Each sFieldName In arrFieldNames
		ScriptColumnBlobs oAccess, oBlobScriptStream, sOutputFolder, sSubFolder, sTableName, sFieldName
	Next

	oBlobScriptStream.Close
	oScriptStream.WriteLine "ExecuteFile " & ImportPath(sSubFolder, sTableName & ".VBS")
End Function


Function ScriptColumnBlobs(oAccess, oScriptStream, sOutputFolder, sSubFolder, sTableName, sColumnName)
	Dim oDatabase, oIndex, oRecordset

	Set oDatabase = oAccess.CurrentDb
	Set oIndex = GetPrimaryKey(oDatabase.TableDefs(sTableName))
	Set oRecordset = oDatabase.OpenRecordset("SELECT *" _
		& " FROM [" & sTableName & "]" _
		& " WHERE [" & sColumnName & "] IS NOT NULL")

	If Not oRecordset.EOF Then
		oScriptStream.WriteLine "Set oDatabase = oAccess.CurrentDb"
		oScriptStream.WriteLine "Set oRecordset = oDatabase.OpenRecordset(""" & sTableName & """)"
		oScriptStream.WriteLine "oRecordset.Index = """ & oIndex.Name & """"
		While Not oRecordset.EOF
			ScriptBlob oScriptStream, sOutputFolder, sSubFolder, oRecordset, sColumnName, oIndex
			oRecordset.MoveNext
		Wend
		oScriptStream.WriteLine "oRecordset.Close"
		oScriptStream.WriteLine "Set oDatabase = Nothing"
		oScriptStream.WriteLine
	End If

	oRecordset.Close
End Function


Function ScriptBlob(oScriptStream, sOutputFolder, sSubFolder, oRecordset, sColumnName, oIndex)
	Dim sFilename, oField

	sFilename = SaveBlob(sOutputFolder, sSubFolder, oRecordset(sColumnName).Value)

	oScriptStream.Write "oRecordset.Seek ""="""
	For Each oField In oIndex.Fields
		oScriptStream.Write ", " & ValueSQL(oRecordset(oField.Name))
	Next

	oScriptStream.WriteLine " : LoadBlob oRecordset, """ & sColumnName & """, " _
		& ImportPath(sSubFolder, sFilename)
End Function


Dim dictMD5Sums : Set dictMD5Sums = Nothing
Dim oStream : Set oStream = Nothing

' Returns filename
Function SaveBlob(sOutputFolder, sSubFolder, arrBytes)
	Dim sMD5Sum, sExportPath

	If dictMD5Sums Is Nothing Then
		' Initialize global variables
		Set dictMD5Sums = CreateObject("Scripting.Dictionary")
		Set oStream = CreateObject("ADODB.Stream")
		oStream.Type = adTypeBinary
		oStream.Open
	End If

	sMD5Sum = MD5Sum(arrBytes)

	If Not dictMD5Sums.Exists(sMD5Sum) Then
		sExportPath = ExportPath(sOutputFolder, sSubFolder, sMD5Sum & ".DAT")
		oStream.Write arrBytes
		oStream.SaveToFile sExportPath, adSaveCreateOverWrite
		dictMD5Sums.Add sMD5Sum, sExportPath
	End If

	SaveBlob = sMD5Sum & ".DAT"
End Function


Dim oMD5 : Set oMD5 = Nothing

' Returns a hex string
Function MD5Sum(arrBytes)
	If oMD5 Is Nothing Then
		' Initialize global variable
		Set oMD5 = CreateObject("System.Security.Cryptography.MD5CryptoServiceProvider")
		oMD5.Initialize()
	End If

	MD5Sum = BytesToHex(oMD5.ComputeHash_2((arrBytes)))
End Function


Function BytesToHex(arrBytes)
	Dim i

	BytesToHex = ""
	For i = 1 To Lenb(arrBytes)
		BytesToHex = BytesToHex & Right("0" & Hex(Ascb(Midb(arrBytes, i, 1))), 2)
	Next
End Function


Function GetPrimaryKey(oTableDef)
	Dim oIndex

	For Each oIndex In oTableDef.Indexes
		If oIndex.Primary Then
			Set GetPrimaryKey = oIndex
			Exit Function
		End If
	Next

	Err.Raise 513, , oTableDef.Name & " has no primary key"
End Function


' Return an array of table names in an order such that child tables
' appear after their parents (i.e. a topological sort).
Function OrderTables(db)
	Dim oRelation, oTableDef, dictParents, dictChildren
	Dim arrOrdered(), orderedCount, i
	Dim sParentName, sChildName

	Set dictParents = CreateObject("Scripting.Dictionary")
	Set dictChildren = CreateObject("Scripting.Dictionary")
	For Each oRelation In db.Relations
		If Not dictChildren.Exists(oRelation.ForeignTable) Then
			dictChildren.Add oRelation.ForeignTable, CreateObject("Scripting.Dictionary")
		End If
		dictChildren(oRelation.ForeignTable).Add oRelation.Table, oRelation

		If Not dictParents.Exists(oRelation.Table) Then
			dictParents.Add oRelation.Table, CreateObject("Scripting.Dictionary")
		End If
		dictParents(oRelation.Table).Add oRelation.ForeignTable, oRelation
	Next

	' Root nodes are those tables *not* in dictChildren
	orderedCount = 0
	For Each oTableDef In db.TableDefs
		If Left(oTableDef.Name, 4) <> "MSys" And Not dictChildren.Exists(oTableDef.Name) Then
			ReDim Preserve arrOrdered(orderedCount)
			arrOrdered(orderedCount) = oTableDef.Name
			orderedCount = orderedCount + 1
		End If
	Next

	i = 0
	While i <= UBound(arrOrdered)
		sParentName = arrOrdered(i)
		If dictParents.Exists(sParentName) Then
			For Each sChildName In dictParents(sParentName)
				dictChildren(sChildName).Remove sParentName
				If dictChildren(sChildName).Count = 0 Then
					dictChildren.Remove sChildName
					ReDim Preserve arrOrdered(orderedCount)
					arrOrdered(orderedCount) = sChildName
					orderedCount = orderedCount + 1
				End If
			Next
			dictParents.Remove sParentName
		End If
		i = i + 1
	Wend

	OrderTables = arrOrdered
End Function


Function ScriptProperties(oAccess, oScriptStream)
	Dim oProp

	For Each oProp In oAccess.CurrentDb.Properties
		If Not isReadOnlyProperty(oProp.Name) Then
			oScriptStream.WriteLine "SetProperty oAccess, """ & oProp.Name & """, " & CStr(oProp.Type) & ", """ & Replace(oProp.Value, """", """""") & """"
		End If
	Next
	oScriptStream.WriteLine
End Function


Function ScriptReferences(oAccess, oScriptStream)
	' Remove all initial references (except "builtin" ones)
	oScriptStream.WriteLine "For Each oRef In oAccess.References"
	oScriptStream.WriteLine "	If Not oRef.BuiltIn Then oAccess.References.Remove oRef"
	oScriptStream.WriteLine "Next"

	Dim oRef
	For Each oRef in oAccess.References
		If Not oRef.BuiltIn Then
			oScriptStream.WriteLine "oAccess.References.AddFromGuid """ & oRef.Guid & """ , " & CStr(oRef.Major) & ", " & Cstr(oRef.Minor)
		End If
	Next
	oScriptStream.WriteLine
End Function


Function ScriptObject(oAccess, oScriptStream, sOutputFolder, sObjectName, objectType, sSubFolder, sExtension)
	Dim sFileName

	sFileName = sObjectName & "." & sExtension
	oAccess.SaveAsText objectType, sObjectName, ExportPath(sOutputFolder, sSubFolder, sFileName)
	oScriptStream.WriteLine "oAccess.LoadFromText " & CStr(objectType) & ", """ & sObjectName & """, " & ImportPath(sSubFolder, sFileName)
End Function


Function ScriptObjects(oAccess, oScriptStream, sOutputFolder, collObjects, objectType, sFolderSuffix, sExtension)
	Dim i, obj, sSubFolder

	If collObjects.Count = 0 Then Exit Function

	oAccess.SysCmd acSysCmdInitMeter, "Decomposing " & sFolderSuffix, collObjects.Count
	sSubFolder = fso.GetBaseName(oAccess.CurrentProject.Name) & "-" & sFolderSuffix

	For i = 0 To collObjects.Count - 1
		Set obj = collObjects(i)
		ScriptObject oAccess, oScriptStream, sOutputFolder, obj.FullName, objectType, sSubFolder, sExtension
		oAccess.SysCmd acSysCmdUpdateMeter, i
	Next

	oScriptStream.WriteLine
	oAccess.SysCmd acSysCmdRemoveMeter
	oAccess.SysCmd acSysCmdSetStatus, " "
End Function


Function ScriptCreate(oAccess, oScriptStream)
	Dim sLocale, options

	sLocale = getLocale(oAccess.CurrentDb)
	options = getVersion(oAccess.CurrentDb)

	oScriptStream.WriteLine "Set fso = CreateObject(""Scripting.FileSystemObject"")"
	oScriptStream.WriteLine "sInputFolder = fso.GetParentFolderName(WScript.ScriptFullName)"
	oScriptStream.WriteLine "If WScript.Arguments.Count = 1 Then"
	oScriptStream.WriteLine "    sOutputFile = fso.GetAbsolutePathName(WScript.Arguments(0))"
	oScriptStream.WriteLine "Else"
	oScriptStream.WriteLine "    sOutputFile = fso.BuildPath(sInputFolder, """ & oAccess.CurrentProject.Name & """)"
	oScriptStream.WriteLine "End If"
	oScriptStream.WriteLine
	oScriptStream.WriteLine "Set oAccess = CreateObject(""Access.Application"")"
	oScriptStream.WriteLine "Set db = oAccess.DBEngine.Workspaces(0).CreateDatabase(sOutputFile, """ & sLocale & """, " & options & ")"
	oScriptStream.WriteLine "db.Close"
	oScriptStream.WriteLine "oAccess.Visible = True"
	oScriptStream.WriteLine "oAccess.RunCommand " & CStr(acCmdAppMaximize)
	oScriptStream.WriteLine "oAccess.Visible = False"
	oScriptStream.WriteLine "oAccess.OpenCurrentDatabase sOutputFile"
	oScriptStream.WriteLine
End Function


Function ScriptClose(oAccess, oScriptStream)
	oScriptStream.WriteLine "MsgBox ""Re-composed "" + oAccess.CurrentProject.FullName + ""."", vbInformation, ""Decompose MS-Access"""
	oScriptStream.WriteLine "oAccess.CloseCurrentDatabase"
	oScriptStream.WriteLine "oAccess.Quit"
	oScriptStream.WriteLine
End Function


Function ExportPath(sOutputFolder, sSubFolder, sFileName)
	Dim sFolderPath

	sFolderPath = fso.BuildPath(sOutputFolder, sSubFolder)
	If Not fso.FolderExists(sFolderPath) Then
		fso.CreateFolder(sFolderPath)
	End If

	ExportPath = fso.BuildPath(sFolderPath, sFileName)
End Function


Function ImportPath(sSubFolder, sFileName)
        ImportPath = "fso.BuildPath(sInputFolder, """ & sSubFolder & "\" & sFileName & """)"
End Function


Function getLocale(db)
	Dim sLocale

	Select Case db.CollatingOrder
	Case 1033 ' dbLangGeneral
		sLocale = ";LANGID=0x0409;CP=1252;COUNTRY=0"
	Case 1025 ' dbLangArabic
		sLocale = ";LANGID=0x0401;CP=1256;COUNTRY=0"
	Case 2052 ' dbSorChineseSimplified
		sLocale = ";LANGID=0x0804;CP=936;COUNTRY=0"
	Case 1028 ' dbSorChineseTraditional
		sLocale = ";LANGID=0x0404;CP=950;COUNTRY=0"
	Case 1049 ' dbSorCyrillic
		sLocale = ";LANGID=0x0419;CP=1251;COUNTRY=0"
	Case 1029 ' dbSortCzech
		sLocale = ";LANGID=0x0405;CP=1250;COUNTRY=0"
	Case 1043 ' dbSortDutch
		sLocale = ";LANGID=0x0413;CP=1252;COUNTRY=0"
	Case 1032 ' dbSortGreek
		sLocale = ";LANGID=0x0408;CP=1253;COUNTRY=0"
	Case 1037 ' dbSortHebrew
		sLocale = ";LANGID=0x040D;CP=1255;COUNTRY=0"
	Case 1038 ' dbSortHungarian
		sLocale = ";LANGID=0x040E;CP=1250;COUNTRY=0"
	Case 1039 ' dbSortIcelandic
		sLocale = ";LANGID=0x040F;CP=1252;COUNTRY=0"
	Case 1041 ' dbSortJapanese
		sLocale = ";LANGID=0x0411;CP=932;COUNTRY=0"
	Case 1042 ' dbSortKorean
		sLocale = ";LANGID=0x0412;CP=949;COUNTRY=0"
	Case 1030 ' dbSortNorwDan
		sLocale = ";LANGID=0x0406;CP=1252;COUNTRY=0"
	Case 1045 ' dbSortNorwDan
		sLocale = ";LANGID=0x0415;CP=1250;COUNTRY=0"
	Case 1060 ' dbSortSlovenian
		sLocale = ";LANGID=0x0424;CP=1250;COUNTRY=0"
	Case 1034 ' dbSortSpanish
		sLocale = ";LANGID=0x040A;CP=1252;COUNTRY=0"
	Case 1053 ' dbSortSwedFin
		sLocale = ";LANGID=0x041D;CP=1252;COUNTRY=0"
	Case 1054 ' dbSortThai
		sLocale = ";LANGID=0x041E;CP=874;COUNTRY=0"
	Case 1055 ' dbSortTurkish
		sLocale = ";LANGID=0x041F;CP=1254;COUNTRY=0"
	Case Else
		Err.Raise "Unknown collating order", , 513
	End Select

	getLocale = sLocale
End Function

Function getVersion(db)
	Dim version

	Select Case db.Version
	Case "1.0"
		version = 1
	Case "1.1"
		version = 8
	Case "2.0"
		version = 16
	Case "3.0"
		version = 32
	Case "4.0"
		version = 64
	Case Else
		Err.Raise "Unknown JET version", , 513
	End Select

	getVersion = version
End Function

Function isReadOnlyProperty(sPropName)
	' Access 2007 database properties are documented here:
	' http://msdn.microsoft.com/en-us/library/ee291998(office.12).aspx

	Select Case sPropName
	Case "CollatingOrder", "Connect", "Connection", "Name", "RecordsAffected", _
	  "Transactions", "Updatable", "Version"
		isReadOnlyProperty = True
	Case "DesignMasterID", "ReplicaID"
		' Decomposing replicated databases has not been tested
		isReadOnlyProperty = True
	Case Else
		isReadOnlyProperty = False
	End Select
End Function


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'                            MAINLINE                             '
'                                                                 '
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Dim fso, sInputFile, sOutputFolder, oAccess

If (WScript.Arguments.Count <> 1 And WScript.Arguments.Count <> 2) Then 
	Usage()
	WScript.Quit() 
End If

Set fso = CreateObject("Scripting.FileSystemObject")
sInputFile = fso.GetAbsolutePathName(WScript.Arguments(0))

If WScript.Arguments.Count = 2 Then
	sOutputFolder = fso.GetAbsolutePathName(WScript.Arguments(1))
Else
	sOutputFolder = fso.GetParentFolderName(sInputFile)
End If

Set oAccess = CreateObject("Access.Application")

' If database is unsigned and needs to show the "Security Warning" dialog,
' then it appears in a window half the screen width, and unless we maximize
' now then this annoying window size will be remembered next time Access
' is run.
oAccess.Visible = True
oAccess.RunCommand acCmdAppMaximize
oAccess.OpenCurrentDatabase sInputFile

DecomposeDatabase oAccess, sOutputFolder
oAccess.CloseCurrentDatabase
oAccess.Quit 

MsgBox sInputFile + " decomposed to folder " + sOutputFolder + ".", vbInformation, "Decompose MS-Access"
WScript.Quit()
